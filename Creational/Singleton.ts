// Плюсы и минусы
// + Можете быть уверены, что у класса есть только один экземпляр.
// + Вы получаете глобальную точку доступа к этому экземпляру.
// + Объект-синглтон инициализируется только при первом запросе.
// - Нарушает принцип единственной ответственности . Данный шаблон решает одновременно две проблемы.
// - Паттерн «одиночка» может маскировать неудачный дизайн, например, когда компоненты программы слишком много знают друг о друге.
// - Данный подход требует особого подхода в многопоточной среде, чтобы несколько потоков не создавали объект-синглтон несколько раз.
// - Проведение модульного тестирования клиентского кода синглтона может быть затруднительным, поскольку многие тестовые фреймворки полагаются на наследование при создании фиктивных объектов.Так как конструктор класса синглтона является приватным, а переопределение статических методов невозможно в большинстве языков, вам придётся придумать креативный способ создания фиктивных объектов для синглтона.Или просто не писать тесты.Или не использовать паттерн «Синглтон».
class Singleton {
  static #instance: Singleton;

  private constructor() {
    // Private constructor to prevent instantiation
  }

  public static get Instance(): Singleton {
    if (!Singleton.#instance) {
      Singleton.#instance = new Singleton();
    }
    return Singleton.#instance;
  }

  public someBusinessLogic() {
    console.log('Executing some business logic.');
  }
}
// Singleton усложняет тестирование,
// потому что содержит глобальное состояние,
// которое разделяется между тестами.
// изолируют инициализацию класса,
// создается инстанс класса только один раз, а потом достается из кэша
// в системе есть только один объект с общим состоянием
