// Factory Method — создаёт один продукт
// Factory Method — «что именно создать?»
// использование в главном классе а создание объектов переносится в подклассы

// Плюсы и минусы
// + Вы избегаете тесной связи между создателем и конкретными изделиями.
// + Принцип единственной ответственности . Вы можете переместить код создания продукта в одно место в программе, что упростит его поддержку.
// + Принцип открытости/закрытости . Вы можете добавлять новые типы продуктов в программу, не нарушая работу существующего клиентского кода.
// - Код может стать более сложным, поскольку для реализации шаблона потребуется ввести множество новых подклассов. В идеале шаблон следует внедрять в существующую иерархию классов-создателей.
interface Product {
  operation(): string;
}

abstract class Creater {
  public abstract factoryMethod(): Product;

  public someOperation(): string {
    const product = this.factoryMethod();
    return `Creator: The same creator's code has just worked with ${product.operation()}`;
  }
}

class ConcreateCreater extends Creater {
  public factoryMethod(): Product {
    return new ConcreateProduct();
  }
}

class ConcreateProduct implements Product {
  public operation(): string {
    return '{Result of the ConcreateProduct}';
  }
}

function clientCode(creator: Creater) {
  console.log(creator.someOperation());
}
//Мы вызываем функцию clientCode, вызываем someOperation() из внутрянки ConcreateCreater,
// внутри ConcreateCreater такой функции нет поэтому он идет в абстрактный класс родителя Create
// someOperation() внутри себя вызывает factoryMethod() который уже переопределен в ConcreateCreater
// из-за того что в factoryMethod()  создается инстанс ConcreateProduct,
// вызывается метод operation() из ConcreateProduct
clientCode(new ConcreateCreater());
// Фабричный метод — это порождающий шаблон проектирования который предоставляет интерфейс
// для создания объектов в суперклассе,
//но позволяет подклассам изменять тип создаваемых объектов.

// Все продукты должны соответствовать одному и тому же интерфейсу. Этот интерфейс должен объявлять методы, которые имеют смысл для каждого продукта.

// Добавьте пустой фабричный метод в класс Creator. Тип возвращаемого значения метода должен соответствовать общему интерфейсу продукта.

// В коде создателя найдите все ссылки на конструкторы продукта. Поочередно замените их вызовами фабричного метода, вынеся код создания продукта в фабричный метод.

// Возможно, вам потребуется добавить временный параметр в фабричный метод для управления типом возвращаемого продукта.

// На данном этапе код фабричного метода может выглядеть довольно некрасиво. В нём может содержаться длинное switchвыражение, определяющее, какой класс продукта следует создать. Но не волнуйтесь, мы скоро это исправим.

// Теперь создайте набор подклассов-создателей для каждого типа продукта, перечисленного в методе фабрики. Переопределите метод фабрики в подклассах и выделите соответствующие фрагменты кода создания из базового метода.

// Если типов товаров слишком много, и создавать подклассы для всех из них не имеет смысла, можно повторно использовать параметр управления из базового класса в подклассах.
