// Iterator — это способ пройтись по коллекции, не зная, как она устроена внутри
//  обходить элементы коллекции, не раскрывая её базовое представление(список, стек, дерево и т.д.).
//  один из наиболее часто используемых типов данных в программировании. Тем не менее, коллекция — это всего лишь контейнер для группы объектов.

// Плюсы и минусы
// + Принцип единственной ответственности . Вы можете упростить клиентский код и коллекции, выделив громоздкие алгоритмы обхода в отдельные классы.
// + Принцип открытости/закрытости . Вы можете реализовывать новые типы коллекций и итераторов и передавать их в существующий код, не нарушая его работу.
// + Вы можете параллельно перебирать элементы одной и той же коллекции, поскольку каждый объект-итератор содержит собственное состояние итерации.
// + По той же причине вы можете отложить итерацию и продолжить ее при необходимости.
// - Применение этого шаблона может быть излишним, если ваше приложение работает только с простыми коллекциями.
// - Использование итератора может быть менее эффективным, чем непосредственный обход элементов некоторых специализированных коллекций.
//
// Итератор — это поведенческий шаблон проектирования, позволяющий последовательно перемещаться по сложной структуре данных, не раскрывая её внутренних деталей.
//

// Iterator(интерфейс);
// Контракт для обхода коллекции
// «дай следующий элемент или скажи, что элементы закончились»
// Контракт для обхода коллекции
// «дай следующий элемент или скажи, что элементы закончились»
interface MyIterator<T> {
  next(): T | null;
}

// Collection
// Объект, который хранит данные,
// но НЕ отвечает за перебор
class WordsCollection {
  private items: string[] = [];

  add(word: string) {
    this.items.push(word);
  }
  // Создание итератора
  getIterator(): MyIterator<string> {
    let index = 0;
    const items = this.items;

    return {
      next(): string | null {
        if (index < items.length) {
          return items[index++];
        }
        return null;
      },
    };
  }
}

const collection = new WordsCollection();
collection.add('First');
collection.add('Second');
collection.add('Third');

// Если бы index был в коллекции:
// нельзя было бы иметь два обхода одновременно
// разные клиенты мешали бы друг другу
const iterator = collection.getIterator();

let word = iterator.next();
while (word !== null) {
  console.log(word);
  word = iterator.next();
}

// Когда Iterator реально нужен
// ✅ Нужен:
// сложная структура (дерево, граф, API)
// разные способы обхода
// нельзя раскрывать внутреннее устройство
// ❌ Не нужен:
// простой массив
// одноразовый for
