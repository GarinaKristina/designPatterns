// позволяет определить основу алгоритма в базовом классе и позволить подклассам переопределять шаги без изменения общей структуры алгоритма.
// Абстрактные шаги должны быть реализованы каждым подклассом.
// Для необязательных шагов уже предусмотрена реализация по умолчанию, но при необходимости ее можно переопределить.

// Плюсы и минусы
// + Вы можете разрешить клиентам переопределять только определенные части большого алгоритма, что сделает их менее подверженными влиянию изменений, происходящих в других частях алгоритма.
// + Дублирующийся код можно поместить в суперкласс.
// - Возможности некоторых клиентов могут быть ограничены предоставленной базовой структурой алгоритма.
// - Вы можете нарушить принцип подстановки Лискова , подавив реализацию шага по умолчанию с помощью подкласса.
// - Чем больше шагов в шаблонных методах, тем сложнее их поддерживать.
abstract class AbstractClass {
  //нельзя создать экземляр этого класса напрямую, только через подклассы
  public templateMethod(): void {
    this.baseOperation();
    this.requiredOperation1();
  }

  protected baseOperation(): void {
    console.log('AbstractClass:base operation');
  }

  protected abstract requiredOperation1(): void; //обязательный метод для подклассов, может вызываться только внутри шаблона
}

class Concrete1 extends AbstractClass {
  // Если сделать метод public, то:
  // клиент сможет вызвать шаг напрямую
  // нарушается инкапсуляция
  // алгоритм «ломается»
  protected requiredOperation1(): void {
    //потому что нельзя расширять уровень доступа при переопределении
    // Клиент вызывает только шаблон
    // Шаги алгоритма — внутреннее дело класса
    console.log('ConcreteClass1: operation 1');
  }
}

class Concrete2 extends AbstractClass {
  protected requiredOperation1(): void {
    console.log('ConcreteClass2: operation 1');
  }
}

function clientCode4(abstractClass: AbstractClass) {
  abstractClass.templateMethod();
}
clientCode4(new Concrete1());
clientCode4(new Concrete2());

// Фабричный метод — это специализация шаблонного метода .
//  При этом фабричный метод может служить шагом в большом шаблонном методе.

// Метод шаблона основан на наследовании: он позволяет изменять части алгоритма,
//  расширяя эти части в подклассах.Стратегия основана на композиции: вы можете изменять
//  части поведения объекта, предоставляя ему различные стратегии, соответствующие этому поведению.
//  Метод шаблона работает на уровне класса, поэтому он статичен.Стратегия работает на уровне объекта,
//  позволяя переключать поведение во время выполнения.
