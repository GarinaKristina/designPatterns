//  позволяет определить семейство алгоритмов, поместить каждый из них в отдельный класс и сделать их объекты взаимозаменяемыми.

// Представьте, что вам нужно добраться до аэропорта. Вы можете сесть на автобус, заказать такси или поехать на велосипеде.
//  Это ваши варианты передвижения.Вы можете выбрать один из вариантов в зависимости от таких факторов, как бюджет или временные ограничения.

// Используйте шаблон проектирования «Стратегия», если хотите применять различные варианты алгоритма
// внутри объекта и иметь возможность переключаться между алгоритмами во время выполнения.

// Паттерн «Стратегия» позволяет косвенно изменять поведение объекта во время выполнения,
// связывая его с различными подобъектами, которые могут выполнять определенные подзадачи разными способами.

// Плюсы и минусы
// + Вы можете заменять алгоритмы, используемые внутри объекта, во время выполнения.
// + Детали реализации алгоритма можно изолировать от кода, который его использует.
// + Наследование можно заменить композицией.
// + Принцип открытости/закрытости . Вы можете внедрять новые стратегии, не меняя контекст.
// -  Если у вас всего пара алгоритмов, и они редко меняются, нет реальной причины чрезмерно
// - усложнять программу новыми классами и интерфейсами, которые появляются вместе с этим шаблоном.
// - Клиенты должны понимать различия между стратегиями, чтобы иметь возможность выбрать подходящую.
// - Многие современные языки программирования поддерживают функциональную типизацию, позволяющую реализовывать
// - различные версии алгоритма внутри набора анонимных функций.Таким образом, эти функции можно использовать точно так же,
// - как и объекты стратегий, но без перегрузки кода дополнительными классами и интерфейсами.

//интерфейс стратегии
interface PaymentStrategy {
  pay(amount: number): void;
}

// конкретная стратегия
class CardPayment implements PaymentStrategy {
  pay(amount: number): void {
    console.log(`Pay ${amount} with card`);
  }
}

class CashPayment implements PaymentStrategy {
  pay(amount: number): void {
    console.log(`Pay ${amount} with cash`);
  }
}

// контест - Shop не знает, как именно платят
// он просто вызывает pay()
// алгоритм оплаты меняется, код магазина — нет
class Shop {
  constructor(private payment: PaymentStrategy) {}

  setPayment(payment: PaymentStrategy) {
    this.payment = payment;
  }

  checkout(amount: number) {
    this.payment.pay(amount);
  }
}

// клиентский код
const shop = new Shop(new CardPayment());
shop.checkout(100); // Pay 100 with card

shop.setPayment(new CashPayment());
shop.checkout(100); // Pay 100 with cash

// Используйте эту стратегию, когда у вас много похожих классов, которые отличаются только способом выполнения определенного действия.

// Паттерн «Стратегия» позволяет вынести изменяющееся поведение в отдельную иерархию классов и
//  объединить исходные классы в один, тем самым уменьшая дублирование кода.

// Используйте этот шаблон, чтобы отделить бизнес-логику класса от деталей реализации алгоритмов,
//  которые могут быть не столь важны в контексте этой логики.

// Паттерн «Стратегия» позволяет изолировать код, внутренние данные и зависимости различных алгоритмов
//  от остального кода.Различные клиенты получают простой интерфейс для выполнения алгоритмов и переключения между ними во время выполнения.

// Используйте этот шаблон, если ваш класс содержит большое условное выражение, переключающееся между
//  различными вариантами одного и того же алгоритма.

// Паттерн «Стратегия» позволяет обойтись без подобного условного оператора, выделив все алгоритмы
// в отдельные классы, каждый из которых реализует один и тот же интерфейс.Исходный объект делегирует выполнение одному из этих объектов, вместо того чтобы реализовывать все варианты алгоритма.

// Функция Decorator позволяет изменить внешний вид объекта, а функция Strategy — его внутреннюю структуру.
